// ===== EMBEDDING DATABASE SERVICE =====

import { PrismaClient, Embedding as PrismaEmbedding, EmbeddingType } from '@prisma/client';
import {
  Embedding,
  CreateEmbeddingRequest,
  UpdateEmbeddingRequest,
  EmbeddingListRequest,
  EmbeddingSearchRequest,
  EmbeddingSearchResult,
  EmbeddingBatch,
  EmbeddingBatchResult,
  EMBEDDING_ERRORS,
  EMBEDDING_CONFIG,
  validateEmbeddingDimension,
  validateContentType,
  validateContentLength,
  validateSimilarityThreshold
} from './embedding-types';

export class EmbeddingService {
  private prisma: PrismaClient;

  constructor(prisma: PrismaClient) {
    this.prisma = prisma;
  }

  // ===== CREATE OPERATIONS =====

  /**
   * Create a new embedding
   */
  async createEmbedding(
    businessId: string,
    request: CreateEmbeddingRequest
  ): Promise<Embedding> {
    // Validate input
    if (!validateContentType(request.contentType)) {
      throw new Error(EMBEDDING_ERRORS.INVALID_CONTENT_TYPE);
    }

    if (!validateEmbeddingDimension(request.embedding)) {
      throw new Error(EMBEDDING_ERRORS.INVALID_EMBEDDING_DIMENSION);
    }

    if (!validateContentLength(request.content)) {
      throw new Error(EMBEDDING_ERRORS.CONTENT_TOO_LONG);
    }

    // Check if embedding already exists
    const existing = await this.prisma.embedding.findUnique({
      where: {
        businessId_contentType_contentId: {
          businessId,
          contentType: request.contentType,
          contentId: request.contentId
        }
      }
    });

    if (existing) {
      throw new Error(EMBEDDING_ERRORS.DUPLICATE_EMBEDDING);
    }

    // Create the embedding
    const embedding = await this.prisma.embedding.create({
      data: {
        businessId,
        contentType: request.contentType,
        contentId: request.contentId,
        content: request.content,
        embedding: request.embedding,
        metadata: request.metadata || {}
      }
    });

    return this.mapPrismaToEmbedding(embedding);
  }

  /**
   * Create multiple embeddings in batch
   */
  async createEmbeddingsBatch(
    businessId: string,
    batch: EmbeddingBatch
  ): Promise<EmbeddingBatchResult> {
    const result: EmbeddingBatchResult = {
      success: true,
      created: 0,
      failed: 0,
      errors: []
    };

    // Process in chunks to avoid overwhelming the database
    const chunkSize = Math.min(EMBEDDING_CONFIG.batchSize, batch.length);
    
    for (let i = 0; i < batch.length; i += chunkSize) {
      const chunk = batch.slice(i, i + chunkSize);
      
      try {
        const embeddings = await Promise.allSettled(
          chunk.map(item => this.createEmbedding(businessId, {
            contentType: item.contentType,
            contentId: item.contentId,
            content: item.content,
            embedding: [], // Will be generated by OpenAI service
            metadata: item.metadata
          }))
        );

        embeddings.forEach((promise, index) => {
          if (promise.status === 'fulfilled') {
            result.created++;
          } else {
            result.failed++;
            result.errors.push({
              contentId: chunk[index].contentId,
              error: promise.reason.message
            });
          }
        });
      } catch (error) {
        result.failed += chunk.length;
        chunk.forEach(item => {
          result.errors.push({
            contentId: item.contentId,
            error: error instanceof Error ? error.message : 'Unknown error'
          });
        });
      }
    }

    return result;
  }

  // ===== READ OPERATIONS =====

  /**
   * Get embedding by ID
   */
  async getEmbeddingById(businessId: string, id: string): Promise<Embedding | null> {
    const embedding = await this.prisma.embedding.findFirst({
      where: {
        id,
        businessId,
        deletedAt: null
      }
    });

    return embedding ? this.mapPrismaToEmbedding(embedding) : null;
  }

  /**
   * Get embedding by content reference
   */
  async getEmbeddingByContent(
    businessId: string,
    contentType: EmbeddingType,
    contentId: string
  ): Promise<Embedding | null> {
    const embedding = await this.prisma.embedding.findUnique({
      where: {
        businessId_contentType_contentId: {
          businessId,
          contentType,
          contentId
        }
      }
    });

    return embedding ? this.mapPrismaToEmbedding(embedding) : null;
  }

  /**
   * List embeddings with filtering and pagination
   */
  async listEmbeddings(
    businessId: string,
    request: EmbeddingListRequest = {}
  ): Promise<{ embeddings: Embedding[]; total: number; hasMore: boolean }> {
    const {
      contentType,
      contentId,
      limit = 50,
      offset = 0,
      includeDeleted = false
    } = request;

    const where: any = {
      businessId
    };

    if (contentType) {
      where.contentType = contentType;
    }

    if (contentId) {
      where.contentId = contentId;
    }

    if (!includeDeleted) {
      where.deletedAt = null;
    }

    const [embeddings, total] = await Promise.all([
      this.prisma.embedding.findMany({
        where,
        orderBy: { createdAt: 'desc' },
        take: limit,
        skip: offset
      }),
      this.prisma.embedding.count({ where })
    ]);

    return {
      embeddings: embeddings.map(this.mapPrismaToEmbedding),
      total,
      hasMore: offset + embeddings.length < total
    };
  }

  /**
   * Search embeddings by similarity (placeholder for vector search)
   * Note: This is a simplified version. In production, you'd use pgvector or similar
   */
  async searchEmbeddings(
    businessId: string,
    request: EmbeddingSearchRequest
  ): Promise<EmbeddingSearchResult[]> {
    const {
      query,
      contentType,
      limit = EMBEDDING_CONFIG.defaultSearchLimit,
      threshold = EMBEDDING_CONFIG.defaultSimilarityThreshold
    } = request;

    if (!validateSimilarityThreshold(threshold)) {
      throw new Error(EMBEDDING_ERRORS.INVALID_SIMILARITY_THRESHOLD);
    }

    // For now, return empty results as we don't have vector search implemented
    // This will be implemented in Phase 2B with OpenAI integration
    const where: any = {
      businessId,
      deletedAt: null
    };

    if (contentType) {
      where.contentType = contentType;
    }

    const embeddings = await this.prisma.embedding.findMany({
      where,
      orderBy: { createdAt: 'desc' },
      take: limit
    });

    // Placeholder similarity calculation
    // In production, this would use proper vector similarity search
    return embeddings.map(embedding => ({
      embedding: this.mapPrismaToEmbedding(embedding),
      similarity: 0.8, // Placeholder
      score: 0.8 // Placeholder
    }));
  }

  // ===== UPDATE OPERATIONS =====

  /**
   * Update an existing embedding
   */
  async updateEmbedding(
    businessId: string,
    id: string,
    request: UpdateEmbeddingRequest
  ): Promise<Embedding> {
    const existing = await this.getEmbeddingById(businessId, id);
    if (!existing) {
      throw new Error(EMBEDDING_ERRORS.EMBEDDING_NOT_FOUND);
    }

    const updateData: any = {};

    if (request.content !== undefined) {
      if (!validateContentLength(request.content)) {
        throw new Error(EMBEDDING_ERRORS.CONTENT_TOO_LONG);
      }
      updateData.content = request.content;
    }

    if (request.embedding !== undefined) {
      if (!validateEmbeddingDimension(request.embedding)) {
        throw new Error(EMBEDDING_ERRORS.INVALID_EMBEDDING_DIMENSION);
      }
      updateData.embedding = request.embedding;
    }

    if (request.metadata !== undefined) {
      updateData.metadata = request.metadata;
    }

    const updated = await this.prisma.embedding.update({
      where: { id },
      data: updateData
    });

    return this.mapPrismaToEmbedding(updated);
  }

  // ===== DELETE OPERATIONS =====

  /**
   * Soft delete an embedding
   */
  async deleteEmbedding(businessId: string, id: string): Promise<boolean> {
    const existing = await this.getEmbeddingById(businessId, id);
    if (!existing) {
      throw new Error(EMBEDDING_ERRORS.EMBEDDING_NOT_FOUND);
    }

    await this.prisma.embedding.update({
      where: { id },
      data: { deletedAt: new Date() }
    });

    return true;
  }

  /**
   * Hard delete an embedding
   */
  async hardDeleteEmbedding(businessId: string, id: string): Promise<boolean> {
    const existing = await this.getEmbeddingById(businessId, id);
    if (!existing) {
      throw new Error(EMBEDDING_ERRORS.EMBEDDING_NOT_FOUND);
    }

    await this.prisma.embedding.delete({
      where: { id }
    });

    return true;
  }

  /**
   * Delete embeddings by content reference
   */
  async deleteEmbeddingsByContent(
    businessId: string,
    contentType: EmbeddingType,
    contentId: string
  ): Promise<number> {
    const result = await this.prisma.embedding.updateMany({
      where: {
        businessId,
        contentType,
        contentId
      },
      data: { deletedAt: new Date() }
    });

    return result.count;
  }

  // ===== UTILITY METHODS =====

  /**
   * Get embedding statistics for a business
   */
  async getEmbeddingStats(businessId: string): Promise<{
    total: number;
    byType: Record<EmbeddingType, number>;
    recent: number; // Last 24 hours
  }> {
    const [total, byType, recent] = await Promise.all([
      this.prisma.embedding.count({
        where: { businessId, deletedAt: null }
      }),
      this.prisma.embedding.groupBy({
        by: ['contentType'],
        where: { businessId, deletedAt: null },
        _count: { contentType: true }
      }),
      this.prisma.embedding.count({
        where: {
          businessId,
          deletedAt: null,
          createdAt: {
            gte: new Date(Date.now() - 24 * 60 * 60 * 1000)
          }
        }
      })
    ]);

    const byTypeMap: Record<EmbeddingType, number> = {
      MENU: 0,
      POLICY: 0,
      FAQ: 0,
      BUSINESS: 0
    };

    byType.forEach(item => {
      byTypeMap[item.contentType] = item._count.contentType;
    });

    return { total, byType: byTypeMap, recent };
  }

  /**
   * Clean up old deleted embeddings
   */
  async cleanupDeletedEmbeddings(olderThanDays: number = 30): Promise<number> {
    const cutoffDate = new Date(Date.now() - olderThanDays * 24 * 60 * 60 * 1000);
    
    const result = await this.prisma.embedding.deleteMany({
      where: {
        deletedAt: {
          not: null,
          lt: cutoffDate
        }
      }
    });

    return result.count;
  }

  // ===== PRIVATE HELPER METHODS =====

  private mapPrismaToEmbedding(prismaEmbedding: PrismaEmbedding): Embedding {
    return {
      id: prismaEmbedding.id,
      businessId: prismaEmbedding.businessId,
      contentType: prismaEmbedding.contentType as EmbeddingType,
      contentId: prismaEmbedding.contentId,
      content: prismaEmbedding.content,
      embedding: prismaEmbedding.embedding as number[],
      metadata: prismaEmbedding.metadata as Record<string, any> || {},
      createdAt: prismaEmbedding.createdAt,
      updatedAt: prismaEmbedding.updatedAt,
      deletedAt: prismaEmbedding.deletedAt || undefined
    };
  }
}

// ===== SINGLETON INSTANCE =====
let embeddingServiceInstance: EmbeddingService | null = null;

export function getEmbeddingService(prisma?: PrismaClient): EmbeddingService {
  if (!embeddingServiceInstance) {
    if (!prisma) {
      throw new Error('PrismaClient instance is required for first initialization');
    }
    embeddingServiceInstance = new EmbeddingService(prisma);
  }
  return embeddingServiceInstance;
}
